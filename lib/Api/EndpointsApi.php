<?php
/**
 * EndpointsApi
 * PHP version 5
 *
 * @category Class
 * @package  tpn
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Telstra Programmable Network API
 *
 * Telstra Programmable Network is a self-provisioning platform that allows its users to create on-demand connectivity services between multiple end-points and add various network functions to those services. Programmable Network enables to connectivity to a global ecosystem of networking services as well as public and private cloud services. Once you are connected to the platform on one or more POPs (points of presence), you can start creating those services based on the use case that you want to accomplish. The Programmable Network API is available to all customers who have registered to use the Programmable Network. To register, please contact your account representative.
 *
 * OpenAPI spec version: 2.4.2
 * Contact: pnapi-support@team.telstra.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.1.2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace tpn\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use tpn\ApiException;
use tpn\Configuration;
use tpn\HeaderSelector;
use tpn\ObjectSerializer;

/**
 * EndpointsApi Class Doc Comment
 *
 * @category Class
 * @package  tpn
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EndpointsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation endpointEndpointuuidGet
     *
     * Get Endpoint name and status
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse2004
     */
    public function endpointEndpointuuidGet($endpointuuid)
    {
        list($response) = $this->endpointEndpointuuidGetWithHttpInfo($endpointuuid);
        return $response;
    }

    /**
     * Operation endpointEndpointuuidGetWithHttpInfo
     *
     * Get Endpoint name and status
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function endpointEndpointuuidGetWithHttpInfo($endpointuuid)
    {
        $request = $this->endpointEndpointuuidGetRequest($endpointuuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse2004' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation endpointEndpointuuidGetAsync
     *
     * Get Endpoint name and status
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointEndpointuuidGetAsync($endpointuuid)
    {
        return $this->endpointEndpointuuidGetAsyncWithHttpInfo($endpointuuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation endpointEndpointuuidGetAsyncWithHttpInfo
     *
     * Get Endpoint name and status
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointEndpointuuidGetAsyncWithHttpInfo($endpointuuid)
    {
        $returnType = '\tpn\Model\InlineResponse2004';
        $request = $this->endpointEndpointuuidGetRequest($endpointuuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'endpointEndpointuuidGet'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function endpointEndpointuuidGetRequest($endpointuuid)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling endpointEndpointuuidGet'
            );
        }

        $resourcePath = '/eis/1.0.0/endpoint/endpointuuid/{endpointuuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation endpointEndpointuuidPut
     *
     * Update Endpoint name
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Endpointupdaterequest $endpointupdaterequest endpointupdaterequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\SuccessFragment|\tpn\Model\Error
     */
    public function endpointEndpointuuidPut($endpointuuid, $endpointupdaterequest = null)
    {
        list($response) = $this->endpointEndpointuuidPutWithHttpInfo($endpointuuid, $endpointupdaterequest);
        return $response;
    }

    /**
     * Operation endpointEndpointuuidPutWithHttpInfo
     *
     * Update Endpoint name
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Endpointupdaterequest $endpointupdaterequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\SuccessFragment|\tpn\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function endpointEndpointuuidPutWithHttpInfo($endpointuuid, $endpointupdaterequest = null)
    {
        $request = $this->endpointEndpointuuidPutRequest($endpointuuid, $endpointupdaterequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\SuccessFragment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\SuccessFragment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\SuccessFragment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\tpn\Model\Error' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\SuccessFragment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\SuccessFragment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation endpointEndpointuuidPutAsync
     *
     * Update Endpoint name
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Endpointupdaterequest $endpointupdaterequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointEndpointuuidPutAsync($endpointuuid, $endpointupdaterequest = null)
    {
        return $this->endpointEndpointuuidPutAsyncWithHttpInfo($endpointuuid, $endpointupdaterequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation endpointEndpointuuidPutAsyncWithHttpInfo
     *
     * Update Endpoint name
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Endpointupdaterequest $endpointupdaterequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointEndpointuuidPutAsyncWithHttpInfo($endpointuuid, $endpointupdaterequest = null)
    {
        $returnType = '\tpn\Model\SuccessFragment';
        $request = $this->endpointEndpointuuidPutRequest($endpointuuid, $endpointupdaterequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'endpointEndpointuuidPut'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Endpointupdaterequest $endpointupdaterequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function endpointEndpointuuidPutRequest($endpointuuid, $endpointupdaterequest = null)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling endpointEndpointuuidPut'
            );
        }

        $resourcePath = '/eis/1.0.0/endpoint/endpointuuid/{endpointuuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($endpointupdaterequest)) {
            $_tempBody = $endpointupdaterequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'application/xml', ]
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'application/xml', ],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation endpointsAssignTopologyTag
     *
     * Assign an Endpoint to a Topology
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Assigntopotagrequest $assigntopotagrequest assigntopotagrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\SuccessFragment
     */
    public function endpointsAssignTopologyTag($endpointuuid, $assigntopotagrequest = null)
    {
        list($response) = $this->endpointsAssignTopologyTagWithHttpInfo($endpointuuid, $assigntopotagrequest);
        return $response;
    }

    /**
     * Operation endpointsAssignTopologyTagWithHttpInfo
     *
     * Assign an Endpoint to a Topology
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Assigntopotagrequest $assigntopotagrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\SuccessFragment, HTTP status code, HTTP response headers (array of strings)
     */
    public function endpointsAssignTopologyTagWithHttpInfo($endpointuuid, $assigntopotagrequest = null)
    {
        $request = $this->endpointsAssignTopologyTagRequest($endpointuuid, $assigntopotagrequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 201:
                    if ('\tpn\Model\SuccessFragment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\SuccessFragment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\SuccessFragment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\SuccessFragment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\SuccessFragment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation endpointsAssignTopologyTagAsync
     *
     * Assign an Endpoint to a Topology
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Assigntopotagrequest $assigntopotagrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsAssignTopologyTagAsync($endpointuuid, $assigntopotagrequest = null)
    {
        return $this->endpointsAssignTopologyTagAsyncWithHttpInfo($endpointuuid, $assigntopotagrequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation endpointsAssignTopologyTagAsyncWithHttpInfo
     *
     * Assign an Endpoint to a Topology
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Assigntopotagrequest $assigntopotagrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsAssignTopologyTagAsyncWithHttpInfo($endpointuuid, $assigntopotagrequest = null)
    {
        $returnType = '\tpn\Model\SuccessFragment';
        $request = $this->endpointsAssignTopologyTagRequest($endpointuuid, $assigntopotagrequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'endpointsAssignTopologyTag'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  \tpn\Model\Assigntopotagrequest $assigntopotagrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function endpointsAssignTopologyTagRequest($endpointuuid, $assigntopotagrequest = null)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling endpointsAssignTopologyTag'
            );
        }

        $resourcePath = '/eis/1.0.0/endpoints/{endpointuuid}/assign_topology_tag';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($assigntopotagrequest)) {
            $_tempBody = $assigntopotagrequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation endpointsTopologyTagUuid
     *
     * List Endpoints for Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20014
     */
    public function endpointsTopologyTagUuid($topotaguuid)
    {
        list($response) = $this->endpointsTopologyTagUuidWithHttpInfo($topotaguuid);
        return $response;
    }

    /**
     * Operation endpointsTopologyTagUuidWithHttpInfo
     *
     * List Endpoints for Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function endpointsTopologyTagUuidWithHttpInfo($topotaguuid)
    {
        $request = $this->endpointsTopologyTagUuidRequest($topotaguuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20014' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20014' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20014', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20014';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation endpointsTopologyTagUuidAsync
     *
     * List Endpoints for Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsTopologyTagUuidAsync($topotaguuid)
    {
        return $this->endpointsTopologyTagUuidAsyncWithHttpInfo($topotaguuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation endpointsTopologyTagUuidAsyncWithHttpInfo
     *
     * List Endpoints for Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsTopologyTagUuidAsyncWithHttpInfo($topotaguuid)
    {
        $returnType = '\tpn\Model\InlineResponse20014';
        $request = $this->endpointsTopologyTagUuidRequest($topotaguuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'endpointsTopologyTagUuid'
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function endpointsTopologyTagUuidRequest($topotaguuid)
    {
        // verify the required parameter 'topotaguuid' is set
        if ($topotaguuid === null || (is_array($topotaguuid) && count($topotaguuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topotaguuid when calling endpointsTopologyTagUuid'
            );
        }

        $resourcePath = '/eis/1.0.0/endpoints/topology_tag_uuid/{topotaguuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($topotaguuid !== null) {
            $resourcePath = str_replace(
                '{' . 'topotaguuid' . '}',
                ObjectSerializer::toPathValue($topotaguuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation endpointsTopologyTagUuidEndpoint
     *
     * Remove Endpoint from a Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function endpointsTopologyTagUuidEndpoint($topotaguuid, $endpointuuid)
    {
        $this->endpointsTopologyTagUuidEndpointWithHttpInfo($topotaguuid, $endpointuuid);
    }

    /**
     * Operation endpointsTopologyTagUuidEndpointWithHttpInfo
     *
     * Remove Endpoint from a Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function endpointsTopologyTagUuidEndpointWithHttpInfo($topotaguuid, $endpointuuid)
    {
        $request = $this->endpointsTopologyTagUuidEndpointRequest($topotaguuid, $endpointuuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation endpointsTopologyTagUuidEndpointAsync
     *
     * Remove Endpoint from a Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsTopologyTagUuidEndpointAsync($topotaguuid, $endpointuuid)
    {
        return $this->endpointsTopologyTagUuidEndpointAsyncWithHttpInfo($topotaguuid, $endpointuuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation endpointsTopologyTagUuidEndpointAsyncWithHttpInfo
     *
     * Remove Endpoint from a Topology
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function endpointsTopologyTagUuidEndpointAsyncWithHttpInfo($topotaguuid, $endpointuuid)
    {
        $returnType = '';
        $request = $this->endpointsTopologyTagUuidEndpointRequest($topotaguuid, $endpointuuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'endpointsTopologyTagUuidEndpoint'
     *
     * @param  string $topotaguuid Unique identifier representing a specific topology tag (required)
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function endpointsTopologyTagUuidEndpointRequest($topotaguuid, $endpointuuid)
    {
        // verify the required parameter 'topotaguuid' is set
        if ($topotaguuid === null || (is_array($topotaguuid) && count($topotaguuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $topotaguuid when calling endpointsTopologyTagUuidEndpoint'
            );
        }
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling endpointsTopologyTagUuidEndpoint'
            );
        }

        $resourcePath = '/eis/1.0.0/endpoints/topology_tag_uuid/{topotaguuid}/endpoint/{endpointuuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($topotaguuid !== null) {
            $resourcePath = str_replace(
                '{' . 'topotaguuid' . '}',
                ObjectSerializer::toPathValue($topotaguuid),
                $resourcePath
            );
        }
        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryEndpoint
     *
     * Get information about the specified endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse2002
     */
    public function inventoryEndpoint($endpointuuid)
    {
        list($response) = $this->inventoryEndpointWithHttpInfo($endpointuuid);
        return $response;
    }

    /**
     * Operation inventoryEndpointWithHttpInfo
     *
     * Get information about the specified endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryEndpointWithHttpInfo($endpointuuid)
    {
        $request = $this->inventoryEndpointRequest($endpointuuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse2002' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryEndpointAsync
     *
     * Get information about the specified endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryEndpointAsync($endpointuuid)
    {
        return $this->inventoryEndpointAsyncWithHttpInfo($endpointuuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryEndpointAsyncWithHttpInfo
     *
     * Get information about the specified endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryEndpointAsyncWithHttpInfo($endpointuuid)
    {
        $returnType = '\tpn\Model\InlineResponse2002';
        $request = $this->inventoryEndpointRequest($endpointuuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryEndpoint'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryEndpointRequest($endpointuuid)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling inventoryEndpoint'
            );
        }

        $resourcePath = '/1.0.0/inventory/endpoint/{endpointuuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryEndpointsCustomeruuid
     *
     * Get list of endpoints for a customer
     *
     * @param  string $customeruuid Unique identifier representing a specific customer (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse2001
     */
    public function inventoryEndpointsCustomeruuid($customeruuid)
    {
        list($response) = $this->inventoryEndpointsCustomeruuidWithHttpInfo($customeruuid);
        return $response;
    }

    /**
     * Operation inventoryEndpointsCustomeruuidWithHttpInfo
     *
     * Get list of endpoints for a customer
     *
     * @param  string $customeruuid Unique identifier representing a specific customer (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryEndpointsCustomeruuidWithHttpInfo($customeruuid)
    {
        $request = $this->inventoryEndpointsCustomeruuidRequest($customeruuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse2001' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryEndpointsCustomeruuidAsync
     *
     * Get list of endpoints for a customer
     *
     * @param  string $customeruuid Unique identifier representing a specific customer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryEndpointsCustomeruuidAsync($customeruuid)
    {
        return $this->inventoryEndpointsCustomeruuidAsyncWithHttpInfo($customeruuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryEndpointsCustomeruuidAsyncWithHttpInfo
     *
     * Get list of endpoints for a customer
     *
     * @param  string $customeruuid Unique identifier representing a specific customer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryEndpointsCustomeruuidAsyncWithHttpInfo($customeruuid)
    {
        $returnType = '\tpn\Model\InlineResponse2001';
        $request = $this->inventoryEndpointsCustomeruuidRequest($customeruuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryEndpointsCustomeruuid'
     *
     * @param  string $customeruuid Unique identifier representing a specific customer (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryEndpointsCustomeruuidRequest($customeruuid)
    {
        // verify the required parameter 'customeruuid' is set
        if ($customeruuid === null || (is_array($customeruuid) && count($customeruuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customeruuid when calling inventoryEndpointsCustomeruuid'
            );
        }

        $resourcePath = '/1.0.0/inventory/endpoints/customeruuid/{customeruuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($customeruuid !== null) {
            $resourcePath = str_replace(
                '{' . 'customeruuid' . '}',
                ObjectSerializer::toPathValue($customeruuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLinksStatsEndpoint
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20018[]
     */
    public function inventoryLinksStatsEndpoint($endpointuuid, $startdate, $enddate)
    {
        list($response) = $this->inventoryLinksStatsEndpointWithHttpInfo($endpointuuid, $startdate, $enddate);
        return $response;
    }

    /**
     * Operation inventoryLinksStatsEndpointWithHttpInfo
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20018[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLinksStatsEndpointWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $request = $this->inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20018[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20018[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20018[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20018[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20018[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLinksStatsEndpointAsync
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointAsync($endpointuuid, $startdate, $enddate)
    {
        return $this->inventoryLinksStatsEndpointAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLinksStatsEndpointAsyncWithHttpInfo
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $returnType = '\tpn\Model\InlineResponse20018[]';
        $request = $this->inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLinksStatsEndpoint'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling inventoryLinksStatsEndpoint'
            );
        }
        // verify the required parameter 'startdate' is set
        if ($startdate === null || (is_array($startdate) && count($startdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startdate when calling inventoryLinksStatsEndpoint'
            );
        }
        // verify the required parameter 'enddate' is set
        if ($enddate === null || (is_array($enddate) && count($enddate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enddate when calling inventoryLinksStatsEndpoint'
            );
        }

        $resourcePath = '/1.0.0/inventory/links-stats/endpoint/{endpointuuid}/{startdate}/{enddate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }
        // path params
        if ($startdate !== null) {
            $resourcePath = str_replace(
                '{' . 'startdate' . '}',
                ObjectSerializer::toPathValue($startdate),
                $resourcePath
            );
        }
        // path params
        if ($enddate !== null) {
            $resourcePath = str_replace(
                '{' . 'enddate' . '}',
                ObjectSerializer::toPathValue($enddate),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLinksStatsEndpointstate
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20020[]
     */
    public function inventoryLinksStatsEndpointstate($endpointuuid, $startdate, $enddate)
    {
        list($response) = $this->inventoryLinksStatsEndpointstateWithHttpInfo($endpointuuid, $startdate, $enddate);
        return $response;
    }

    /**
     * Operation inventoryLinksStatsEndpointstateWithHttpInfo
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20020[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLinksStatsEndpointstateWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $request = $this->inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20020[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20020[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20020[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20020[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20020[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLinksStatsEndpointstateAsync
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointstateAsync($endpointuuid, $startdate, $enddate)
    {
        return $this->inventoryLinksStatsEndpointstateAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLinksStatsEndpointstateAsyncWithHttpInfo
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointstateAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $returnType = '\tpn\Model\InlineResponse20020[]';
        $request = $this->inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLinksStatsEndpointstate'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling inventoryLinksStatsEndpointstate'
            );
        }
        // verify the required parameter 'startdate' is set
        if ($startdate === null || (is_array($startdate) && count($startdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startdate when calling inventoryLinksStatsEndpointstate'
            );
        }
        // verify the required parameter 'enddate' is set
        if ($enddate === null || (is_array($enddate) && count($enddate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enddate when calling inventoryLinksStatsEndpointstate'
            );
        }

        $resourcePath = '/1.0.0/inventory/links-stats/endpointstate/{endpointuuid}/{startdate}/{enddate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }
        // path params
        if ($startdate !== null) {
            $resourcePath = str_replace(
                '{' . 'startdate' . '}',
                ObjectSerializer::toPathValue($startdate),
                $resourcePath
            );
        }
        // path params
        if ($enddate !== null) {
            $resourcePath = str_replace(
                '{' . 'enddate' . '}',
                ObjectSerializer::toPathValue($enddate),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryRegularendpoint
     *
     * Create Physical (Port) Endpoint
     *
     * @param  \tpn\Model\Regendpointrequest $regendpointrequest regendpointrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SuccessFragment
     */
    public function inventoryRegularendpoint($regendpointrequest = null)
    {
        list($response) = $this->inventoryRegularendpointWithHttpInfo($regendpointrequest);
        return $response;
    }

    /**
     * Operation inventoryRegularendpointWithHttpInfo
     *
     * Create Physical (Port) Endpoint
     *
     * @param  \tpn\Model\Regendpointrequest $regendpointrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SuccessFragment, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryRegularendpointWithHttpInfo($regendpointrequest = null)
    {
        $request = $this->inventoryRegularendpointRequest($regendpointrequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('SuccessFragment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('SuccessFragment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'SuccessFragment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'SuccessFragment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'SuccessFragment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryRegularendpointAsync
     *
     * Create Physical (Port) Endpoint
     *
     * @param  \tpn\Model\Regendpointrequest $regendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegularendpointAsync($regendpointrequest = null)
    {
        return $this->inventoryRegularendpointAsyncWithHttpInfo($regendpointrequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryRegularendpointAsyncWithHttpInfo
     *
     * Create Physical (Port) Endpoint
     *
     * @param  \tpn\Model\Regendpointrequest $regendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegularendpointAsyncWithHttpInfo($regendpointrequest = null)
    {
        $returnType = 'SuccessFragment';
        $request = $this->inventoryRegularendpointRequest($regendpointrequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryRegularendpoint'
     *
     * @param  \tpn\Model\Regendpointrequest $regendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryRegularendpointRequest($regendpointrequest = null)
    {

        $resourcePath = '/1.0.0/inventory/regularendpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($regendpointrequest)) {
            $_tempBody = $regendpointrequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryRegularvport
     *
     * Create VPort for physical endpoint
     *
     * @param  \tpn\Model\Regvportrequest $regvportrequest regvportrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SuccessFragment
     */
    public function inventoryRegularvport($regvportrequest = null)
    {
        list($response) = $this->inventoryRegularvportWithHttpInfo($regvportrequest);
        return $response;
    }

    /**
     * Operation inventoryRegularvportWithHttpInfo
     *
     * Create VPort for physical endpoint
     *
     * @param  \tpn\Model\Regvportrequest $regvportrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SuccessFragment, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryRegularvportWithHttpInfo($regvportrequest = null)
    {
        $request = $this->inventoryRegularvportRequest($regvportrequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('SuccessFragment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('SuccessFragment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'SuccessFragment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'SuccessFragment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'SuccessFragment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryRegularvportAsync
     *
     * Create VPort for physical endpoint
     *
     * @param  \tpn\Model\Regvportrequest $regvportrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegularvportAsync($regvportrequest = null)
    {
        return $this->inventoryRegularvportAsyncWithHttpInfo($regvportrequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryRegularvportAsyncWithHttpInfo
     *
     * Create VPort for physical endpoint
     *
     * @param  \tpn\Model\Regvportrequest $regvportrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryRegularvportAsyncWithHttpInfo($regvportrequest = null)
    {
        $returnType = 'SuccessFragment';
        $request = $this->inventoryRegularvportRequest($regvportrequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryRegularvport'
     *
     * @param  \tpn\Model\Regvportrequest $regvportrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryRegularvportRequest($regvportrequest = null)
    {

        $resourcePath = '/1.0.0/inventory/regularvport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($regvportrequest)) {
            $_tempBody = $regvportrequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryVnfendpoint
     *
     * Instantiate Virtual Network Function
     *
     * @param  \tpn\Model\Vnfendpointrequest $vnfendpointrequest vnfendpointrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return SuccessFragment
     */
    public function inventoryVnfendpoint($vnfendpointrequest = null)
    {
        list($response) = $this->inventoryVnfendpointWithHttpInfo($vnfendpointrequest);
        return $response;
    }

    /**
     * Operation inventoryVnfendpointWithHttpInfo
     *
     * Instantiate Virtual Network Function
     *
     * @param  \tpn\Model\Vnfendpointrequest $vnfendpointrequest (optional)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of SuccessFragment, HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryVnfendpointWithHttpInfo($vnfendpointrequest = null)
    {
        $request = $this->inventoryVnfendpointRequest($vnfendpointrequest);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('SuccessFragment' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('SuccessFragment' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'SuccessFragment', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'SuccessFragment';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'SuccessFragment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryVnfendpointAsync
     *
     * Instantiate Virtual Network Function
     *
     * @param  \tpn\Model\Vnfendpointrequest $vnfendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryVnfendpointAsync($vnfendpointrequest = null)
    {
        return $this->inventoryVnfendpointAsyncWithHttpInfo($vnfendpointrequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryVnfendpointAsyncWithHttpInfo
     *
     * Instantiate Virtual Network Function
     *
     * @param  \tpn\Model\Vnfendpointrequest $vnfendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryVnfendpointAsyncWithHttpInfo($vnfendpointrequest = null)
    {
        $returnType = 'SuccessFragment';
        $request = $this->inventoryVnfendpointRequest($vnfendpointrequest);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryVnfendpoint'
     *
     * @param  \tpn\Model\Vnfendpointrequest $vnfendpointrequest (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryVnfendpointRequest($vnfendpointrequest = null)
    {

        $resourcePath = '/1.0.0/inventory/vnfendpoint';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($vnfendpointrequest)) {
            $_tempBody = $vnfendpointrequest;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation vnfendpointVnfuuid
     *
     * Get details of a specific VNF
     *
     * @param  string $vnfuuid Unique identifier representing a specific virtual network function (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse2003
     */
    public function vnfendpointVnfuuid($vnfuuid)
    {
        list($response) = $this->vnfendpointVnfuuidWithHttpInfo($vnfuuid);
        return $response;
    }

    /**
     * Operation vnfendpointVnfuuidWithHttpInfo
     *
     * Get details of a specific VNF
     *
     * @param  string $vnfuuid Unique identifier representing a specific virtual network function (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function vnfendpointVnfuuidWithHttpInfo($vnfuuid)
    {
        $request = $this->vnfendpointVnfuuidRequest($vnfuuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse2003' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation vnfendpointVnfuuidAsync
     *
     * Get details of a specific VNF
     *
     * @param  string $vnfuuid Unique identifier representing a specific virtual network function (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vnfendpointVnfuuidAsync($vnfuuid)
    {
        return $this->vnfendpointVnfuuidAsyncWithHttpInfo($vnfuuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation vnfendpointVnfuuidAsyncWithHttpInfo
     *
     * Get details of a specific VNF
     *
     * @param  string $vnfuuid Unique identifier representing a specific virtual network function (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function vnfendpointVnfuuidAsyncWithHttpInfo($vnfuuid)
    {
        $returnType = '\tpn\Model\InlineResponse2003';
        $request = $this->vnfendpointVnfuuidRequest($vnfuuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'vnfendpointVnfuuid'
     *
     * @param  string $vnfuuid Unique identifier representing a specific virtual network function (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function vnfendpointVnfuuidRequest($vnfuuid)
    {
        // verify the required parameter 'vnfuuid' is set
        if ($vnfuuid === null || (is_array($vnfuuid) && count($vnfuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vnfuuid when calling vnfendpointVnfuuid'
            );
        }

        $resourcePath = '/eis/1.0.0/vnfendpoint/vnfuuid/{vnfuuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($vnfuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'vnfuuid' . '}',
                ObjectSerializer::toPathValue($vnfuuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
