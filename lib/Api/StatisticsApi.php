<?php
/**
 * StatisticsApi
 * PHP version 5
 *
 * @category Class
 * @package  tpn
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Telstra Programmable Network API
 *
 * Telstra Programmable Network is a self-provisioning platform that allows its users to create on-demand connectivity services between multiple end-points and add various network functions to those services. Programmable Network enables to connectivity to a global ecosystem of networking services as well as public and private cloud services. Once you are connected to the platform on one or more POPs (points of presence), you can start creating those services based on the use case that you want to accomplish. The Programmable Network API is available to all customers who have registered to use the Programmable Network. To register, please contact your account representative.
 *
 * OpenAPI spec version: 2.4.2
 * Contact: pnapi-support@team.telstra.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 3.1.2
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace tpn\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use tpn\ApiException;
use tpn\Configuration;
use tpn\HeaderSelector;
use tpn\ObjectSerializer;

/**
 * StatisticsApi Class Doc Comment
 *
 * @category Class
 * @package  tpn
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class StatisticsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation inventoryLinksStatsEndpoint
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20018[]
     */
    public function inventoryLinksStatsEndpoint($endpointuuid, $startdate, $enddate)
    {
        list($response) = $this->inventoryLinksStatsEndpointWithHttpInfo($endpointuuid, $startdate, $enddate);
        return $response;
    }

    /**
     * Operation inventoryLinksStatsEndpointWithHttpInfo
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20018[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLinksStatsEndpointWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $request = $this->inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20018[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20018[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20018[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20018[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20018[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLinksStatsEndpointAsync
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointAsync($endpointuuid, $startdate, $enddate)
    {
        return $this->inventoryLinksStatsEndpointAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLinksStatsEndpointAsyncWithHttpInfo
     *
     * Get statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $returnType = '\tpn\Model\InlineResponse20018[]';
        $request = $this->inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLinksStatsEndpoint'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLinksStatsEndpointRequest($endpointuuid, $startdate, $enddate)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling inventoryLinksStatsEndpoint'
            );
        }
        // verify the required parameter 'startdate' is set
        if ($startdate === null || (is_array($startdate) && count($startdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startdate when calling inventoryLinksStatsEndpoint'
            );
        }
        // verify the required parameter 'enddate' is set
        if ($enddate === null || (is_array($enddate) && count($enddate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enddate when calling inventoryLinksStatsEndpoint'
            );
        }

        $resourcePath = '/1.0.0/inventory/links-stats/endpoint/{endpointuuid}/{startdate}/{enddate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }
        // path params
        if ($startdate !== null) {
            $resourcePath = str_replace(
                '{' . 'startdate' . '}',
                ObjectSerializer::toPathValue($startdate),
                $resourcePath
            );
        }
        // path params
        if ($enddate !== null) {
            $resourcePath = str_replace(
                '{' . 'enddate' . '}',
                ObjectSerializer::toPathValue($enddate),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLinksStatsEndpointstate
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20020[]
     */
    public function inventoryLinksStatsEndpointstate($endpointuuid, $startdate, $enddate)
    {
        list($response) = $this->inventoryLinksStatsEndpointstateWithHttpInfo($endpointuuid, $startdate, $enddate);
        return $response;
    }

    /**
     * Operation inventoryLinksStatsEndpointstateWithHttpInfo
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20020[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLinksStatsEndpointstateWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $request = $this->inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20020[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20020[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20020[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20020[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20020[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLinksStatsEndpointstateAsync
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointstateAsync($endpointuuid, $startdate, $enddate)
    {
        return $this->inventoryLinksStatsEndpointstateAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLinksStatsEndpointstateAsyncWithHttpInfo
     *
     * Get state statistics for endpoint
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsEndpointstateAsyncWithHttpInfo($endpointuuid, $startdate, $enddate)
    {
        $returnType = '\tpn\Model\InlineResponse20020[]';
        $request = $this->inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLinksStatsEndpointstate'
     *
     * @param  string $endpointuuid Unique identifier representing a specific endpoint (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLinksStatsEndpointstateRequest($endpointuuid, $startdate, $enddate)
    {
        // verify the required parameter 'endpointuuid' is set
        if ($endpointuuid === null || (is_array($endpointuuid) && count($endpointuuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpointuuid when calling inventoryLinksStatsEndpointstate'
            );
        }
        // verify the required parameter 'startdate' is set
        if ($startdate === null || (is_array($startdate) && count($startdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startdate when calling inventoryLinksStatsEndpointstate'
            );
        }
        // verify the required parameter 'enddate' is set
        if ($enddate === null || (is_array($enddate) && count($enddate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enddate when calling inventoryLinksStatsEndpointstate'
            );
        }

        $resourcePath = '/1.0.0/inventory/links-stats/endpointstate/{endpointuuid}/{startdate}/{enddate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($endpointuuid !== null) {
            $resourcePath = str_replace(
                '{' . 'endpointuuid' . '}',
                ObjectSerializer::toPathValue($endpointuuid),
                $resourcePath
            );
        }
        // path params
        if ($startdate !== null) {
            $resourcePath = str_replace(
                '{' . 'startdate' . '}',
                ObjectSerializer::toPathValue($startdate),
                $resourcePath
            );
        }
        // path params
        if ($enddate !== null) {
            $resourcePath = str_replace(
                '{' . 'enddate' . '}',
                ObjectSerializer::toPathValue($enddate),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inventoryLinksStatsFlow
     *
     * Get statistics for flow
     *
     * @param  string $linkid Unique identifier representing a specific link (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \tpn\Model\InlineResponse20019[]
     */
    public function inventoryLinksStatsFlow($linkid, $startdate, $enddate)
    {
        list($response) = $this->inventoryLinksStatsFlowWithHttpInfo($linkid, $startdate, $enddate);
        return $response;
    }

    /**
     * Operation inventoryLinksStatsFlowWithHttpInfo
     *
     * Get statistics for flow
     *
     * @param  string $linkid Unique identifier representing a specific link (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \tpn\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \tpn\Model\InlineResponse20019[], HTTP status code, HTTP response headers (array of strings)
     */
    public function inventoryLinksStatsFlowWithHttpInfo($linkid, $startdate, $enddate)
    {
        $request = $this->inventoryLinksStatsFlowRequest($linkid, $startdate, $enddate);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\tpn\Model\InlineResponse20019[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ('\tpn\Model\InlineResponse20019[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\tpn\Model\InlineResponse20019[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\tpn\Model\InlineResponse20019[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\tpn\Model\InlineResponse20019[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation inventoryLinksStatsFlowAsync
     *
     * Get statistics for flow
     *
     * @param  string $linkid Unique identifier representing a specific link (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsFlowAsync($linkid, $startdate, $enddate)
    {
        return $this->inventoryLinksStatsFlowAsyncWithHttpInfo($linkid, $startdate, $enddate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inventoryLinksStatsFlowAsyncWithHttpInfo
     *
     * Get statistics for flow
     *
     * @param  string $linkid Unique identifier representing a specific link (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inventoryLinksStatsFlowAsyncWithHttpInfo($linkid, $startdate, $enddate)
    {
        $returnType = '\tpn\Model\InlineResponse20019[]';
        $request = $this->inventoryLinksStatsFlowRequest($linkid, $startdate, $enddate);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'inventoryLinksStatsFlow'
     *
     * @param  string $linkid Unique identifier representing a specific link (required)
     * @param  string $startdate Start date for statistics query (required)
     * @param  string $enddate End date for statistics query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inventoryLinksStatsFlowRequest($linkid, $startdate, $enddate)
    {
        // verify the required parameter 'linkid' is set
        if ($linkid === null || (is_array($linkid) && count($linkid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $linkid when calling inventoryLinksStatsFlow'
            );
        }
        // verify the required parameter 'startdate' is set
        if ($startdate === null || (is_array($startdate) && count($startdate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $startdate when calling inventoryLinksStatsFlow'
            );
        }
        // verify the required parameter 'enddate' is set
        if ($enddate === null || (is_array($enddate) && count($enddate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enddate when calling inventoryLinksStatsFlow'
            );
        }

        $resourcePath = '/1.0.0/inventory/links-stats/flow/{linkid}/{startdate}/{enddate}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($linkid !== null) {
            $resourcePath = str_replace(
                '{' . 'linkid' . '}',
                ObjectSerializer::toPathValue($linkid),
                $resourcePath
            );
        }
        // path params
        if ($startdate !== null) {
            $resourcePath = str_replace(
                '{' . 'startdate' . '}',
                ObjectSerializer::toPathValue($startdate),
                $resourcePath
            );
        }
        // path params
        if ($enddate !== null) {
            $resourcePath = str_replace(
                '{' . 'enddate' . '}',
                ObjectSerializer::toPathValue($enddate),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
